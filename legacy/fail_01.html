<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Elevator</title>

    <style>
      #container{ border: 2px solid grey; width:300px;  margin-left:100px; margin-top: 10px;}
      #board{ border: 2px solid black; width:400px; height:50px; margin-left: 50px;}
      #ev{margin-left:90px; border: 1px solid black; width: 50px; height: 60px; }
      span {margin-left: 10px;}
      input {margin-left:10px; width:50px; height:30px}
      .floor{height: 90px; padding-top:20px;}
    </style>
  </head>
  <body>
    <h2>Elevator_Fail_01_20181128</h2>
    <div id="board">
      <span id="call">Call: </span><br/>
      <span id="move">Move: </span>
    </div>
    <div id="container"><hr/>
      <div class="floor">
        <input type="button" id="0" value="5" />
      </div><hr/>
      <div class="floor">
        <input type="button" id="1" value="4" />
      </div><hr/>
      <div class="floor">
        <input type="button" id="2" value="3" />
      </div><hr/>
      <div class="floor">
        <input type="button" id="3" value="2" />
      </div><hr/>
      <div class="floor">
        <input type="button" id="4" value="1" />
        <input type="button" id="ev" value="EV" />
      </div><hr/>
    </div>
    <script type="text/javascript">
    //전역변수 모음 (최대한 안 쓰기)
    var call_array = new Array(0);
    var ev_direction = "up";
    var timer;
    var timer_2;

    //이벤트 리스너 걸기
    window.onload = function() {
      let all_floor = document.querySelectorAll('.floor');
      for (let i=0; i<all_floor.length; i++){
        all_floor[i].children[0].addEventListener('click', getBtnCall); //각 층 div 안의 input button
      }
    }

    //버튼 받기(call에 띄움)
    function getBtnCall(){

      let target_floor = parseInt(this.id); //버튼 누른 층 배열 순서 나옴.
      let board_call = document.querySelector('#call');

      //푸시하기 전에 이미 있는거면 중복해서 못넣게 처리
      if(call_array.indexOf(target_floor)==(-1)){

        //중복 없을 시 콜 값 넣음
        call_array.push(target_floor);

        //sort 쓰기 전에 전광판에 현황 띄워주기
        let board_call = document.querySelector('#call');
        board_call.innerHTML=board_call.innerHTML+" "+this.value; //this.value는 배열 순서값 아닌 눈으로 보기에 층수임.
      }

      //array가 한개면 sort 필요 없음
      if(call_array.length==1){

      } else {
        //sort 쓰는데 진행방향에 따라서 쓸 것
        //전역 변수 ev_direction 초기값은 up.
        //특정 층 도달시 더 높은 층 콜이 없을때 방향 down 전환함.
        //(엘베 초기에 1층이며 위로 간다는 가정)
        if(ev_direction=='up'){
          call_array.sort(function(a, b){return b-a});

        } else if(ev_direction=='down'){
          call_array.sort(function(a, b){return a-b});
        }

      }

      moveEle();

    }



    //이동 (up일땐 현재 층 보다 밑에꺼 무시 down 일땐 현재층 보다 높은거 무시)
    function moveEle(){
      let all_floor = document.querySelectorAll('.floor');
      let ev = document.querySelector('#ev');
      let present_floor = parseInt(ev.parentNode.children[0].id);
      let target_floor;
      let i =0;

      if(ev_direction=='up'){
        //그냥 일단 만들기: up일때 sort 순서대로 멈춰섬
        //하나씩 생각해. 배열[0]까지 엘베한칸씩 가고 배열[0]에 문 열림
        for(i=0; i<call_array.length; i++){
          if(present_floor>call_array[i]){
            target_floor=call_array[i];
            i=0;
            break;
          }
        }

        timer = setInterval(function(){
          let distance = present_floor - target_floor;
          if (i++ < distance){
            moveFloor(present_floor-i);

          } else {
            openEle(); //문여는 액션
            clearCall(present_floor);
            clearInterval(timer);
          }
        }, 1000);
      } else if(ev_direction=='down'){

      }



    }

    //엘리베이터 움직임(하나만 생각함)
    function moveFloor(floor_num) {
      let all_floor = document.querySelectorAll('.floor');
      let ev = document.querySelector('#ev');
      console.log(ev);

      all_floor[floor_num].append(ev);

    }

    //엘리베이터 문 열림
    function openEle(){
      let ev = document.querySelector('#ev');
      ev.style.backgroundColor="yellow";
      setTimeout(closeEle, 1000);
    }

    //엘리베이터 문 닫힘
    function closeEle(){
      let ev = document.querySelector('#ev');
      ev.style.backgroundColor="";
    }

    //콜제거 (array와 전광판 모두에서.)
    function clearCall(floor_num){

      //전광판에서 제거
      let board_call = document.querySelector('#call');
      let bc_html = board_call.innerHTML;
      bc_html=bc_html.replace(String(floor_num ), "");
      board_call.innerHTML=bc_html;

      //array에서 제거
      call_array.shift();

    }


    //층수 알고리즘 :  진행방향 고려하여 현재에서 가장 가까운 층으로 감
    //끝까지 가면 진행방향 튼다.  look 알고리즘.
    function sortFloor(){

      if(call_array.length==1){

      } else {
        if(ev_direction=='up'){
          call_array.sort(function(a, b){return b-a});

        } else if(ev_direction=='down'){
          call_array.sort(function(a, b){return a-b});
        }

      }

    }



    //전광판에 층수 눌러진 것(call)에 보여줌

    //몇초 기다렸는지 count 다운해서 알고리즘 별로 점수 보여주기





    </script>
  </body>
</html>
